---
applyTo: "**/*.vue, **/*.ts, **/*.js, **/*.css, **/*.scss"
---

Вот комплексный промпт для GitHub Copilot Instructions, составленный на основе лучших практик разработки на Vue 3. Он фокусируется на понятной, масштабируемой архитектуре (не FSD) и чистом коде.

---

### **GitHub Copilot Instructions: Vue 3 Clean Code & Architecture Guide**

**Цель:** Помогать писать чистый, поддерживаемый и предсказуемый код на Vue 3, следуя согласованным стандартам. Все решения должны способствовать простоте навигации по коду и долгосрочной поддержке проекта.

#### **1. Основные принципы архитектуры**

- **Структура на основе функций (Feature-based):** Организуй исходный код (`/src`) по бизнес-возможностям (например, `user`, `dashboard`, `product`). Это делает код предсказуемым — всё, что относится к одной функции, находится в одном месте.
- **"Плоский" каталог компонентов:** Внутри каждой функции избегай глубокой вложенности папок для компонентов. Используй соглашения об именах для группировки связанных файлов, а не вложенные папки. Это ускоряет поиск и устраняет "паралич анализа".
- **Предсказуемость:** Имя файла должно сразу давать понять о его назначении и месте в приложении. Стремись к такой структуре, чтобы по задаче или названию компонента в DevTools можно было быстро найти соответствующий файл.

#### **2. Структура проекта и именование файлов**

```
src/
├── assets/          # Глобальные статические ресурсы (шрифты, изображения)
├── composables/     # Переиспользуемые композаблы (см. раздел 4)
├── router/          # Конфигурация Vue Router
├── stores/          # Хранилища Pinia (по одному на доменную область)
└── features/        # Функциональные модули (ОСНОВНАЯ СТРУКТУРА)
    ├── auth/        # Функция "Аутентификация"
    │   ├── components/   # Компоненты, используемые ТОЛЬКО внутри этой функции
    │   ├── pages/        # Компоненты-страницы (роуты)
    │   ├── composables/  # Специфичные для функции композаблы (опционально)
    │   └── index.ts      # Публичный API функции (экспорт компонентов, утилит)
    ├── dashboard/   # Функция "Панель управления"
    └── shared/      # Глобально переиспользуемые ресурсы (СМ. ПУНКТ 3)
        ├── components/   # UI-кит и компоненты уровня приложения
        └── utils/        # Общие утилиты, константы, типы
```

#### **3. Правила для компонентов и их именования**

- **Формат файлов:** Всегда используй однофайловые компоненты (SFC) с расширением `.vue` и называй их в **PascalCase**.

  - ✅ `UserProfileCard.vue`
  - ❌ `userProfileCard.vue`, `user-profile-card.vue` (для файлов)

- **Именование компонентов (многословность):** Имена компонентов всегда должны состоять из нескольких слов (кроме корневого `App`), чтобы избежать конфликтов с будущими HTML-элементами.

  - ✅ `UserList`, `AppHeader`
  - ❌ `List`, `Header`

- **Базовые (UI) компоненты:** Компоненты, которые являются строительными блоками UI (кнопки, поля ввода, модальные окна) и не содержат бизнес-логики, помещай в `shared/components/`. Называй их с префиксом **`Base`**, **`App`** или **`V`** (например, `BaseButton.vue`, `AppModal.vue`). Это визуально группирует их и указывает на их глобальную природу.

- **Связанные (дочерние) компоненты:** Компоненты, имеющие смысл только в контексте одного родителя, должны включать имя родителя в качестве префикса.

  - ✅ `UserProfile.vue` (родитель) и `UserProfileAvatar.vue`, `UserProfileSettings.vue` (дочерние).
  - ❌ `Profile.vue`, `Avatar.vue`, `Settings.vue` (разрозненные имена).

- **Порядок слов в имени:** Начинай имя с самого общего (верхнеуровневого) слова и заканчивай описательным.
  - ✅ `SearchButtonClear.vue`, `SettingsCheckboxNotifications.vue`
  - ❌ `ClearSearchButton.vue`, `NotificationsSettingsCheckbox.vue`
  - _Почему:_ При алфавитной сортировке в редакторе все компоненты, связанные с `Search` или `Settings`, будут сгруппированы вместе.

#### **4. Создание композаблов (Composables)**

- **Именование и расположение:** Все переиспользуемые композаблы помещай в папку `/composables` или `features/*/composables`. Называй файлы с префиксом **`use`** и в **camelCase** (например, `useUserData.ts`, `useLocalStorage.ts`).
- **Единая ответственность (SRP):** Каждый композабл должен отвечать за одну четкую задачу (управление счётчиком, запрос к API).
- **Структура композабла:** Следуй единому порядку внутри:
  1.  **Реактивное состояние** (`ref`, `reactive`).
  2.  **Вычисляемые свойства** (`computed`).
  3.  **Функции (методы)**.
  4.  **Хуки жизненного цикла** (`onMounted`).
  5.  **Наблюдатели** (`watch`).
- **Возвращаемое значение:** Всегда возвращай объект с реактивным состоянием и методами. Для безопасности используй `readonly()` для состояний, которые не должны изменяться напрямую извне.
  ```javascript
  // ✅ Хорошо: Чёткая структура и возврат
  export function useCounter(initialValue = 0) {
    const count = ref(initialValue);
    const double = computed(() => count.value * 2);
    const increment = () => {
      count.value++;
    };
    return { count: readonly(count), double, increment };
  }
  ```

#### **5. Работа с состоянием (Pinia)**

- **Структура хранилища:** Организуй хранилища по доменным областям (например, `useUserStore`, `useProductStore`) в папке `/stores`.
- **Композиционный синтаксис:** Предпочитай синтаксис Composition API (`defineStore(() => {})`) для Pinia-хранилищ, так как он согласуется с логикой композаблов и предоставляет лучшую типизацию.
- **Локальное vs. Глобальное состояние:** Не злоупотребляй глобальным состоянием. Помещай в хранилище только данные, общие для нескольких _несвязанных_ компонентов. Локальное состояние UI (например, видимость модального окна) должно оставаться в компоненте с помощью `ref`.
- **Использование вне компонентов:** При вызове `useStore()` в файлах за пределами компонентов (например, в роутере) убедись, что экземпляр Pinia уже установлен в приложении. Помещай вызов хранилища внутрь функций (например, в хук навигации Vue Router), чтобы гарантировать это.
  ```javascript
  // ✅ Хорошо: Вызов хранилища внутри хука маршрутизации
  router.beforeEach((to) => {
    const userStore = useUserStore(); // Pinia уже инициализирован
    if (to.meta.requiresAuth && !userStore.isLoggedIn) return "/login";
  });
  ```

#### **6. Работа с маршрутизацией (Vue Router)**

- **Именование страниц:** Компоненты-страницы (лежащие в `features/*/pages/`) именуй по шаблону `[Feature][Action].vue`, используя PascalCase. Это согласует имя компонента и имя роута.
  - `UsersIndex.vue` — путь: `/users`
  - `UsersShow.vue` — путь: `/users/:id`
  - `PostsCreate.vue` — путь: `/posts/create`
- **Использование имён роутов:** В коде всегда ссылайся на роуты по их **имени** (через `name:` в конфигурации), а не по строке пути. Это делает код устойчивым к изменениям URL.
  ```javascript
  // В конфигурации роутера
  { path: '/users/:id/edit', name: 'UsersEdit', component: UsersEdit }
  // В компоненте
  router.push({ name: 'UsersEdit', params: { id: userId } }) // ✅
  ```

#### **7. Чистый код и лучшие практики внутри компонентов**

- **Composition API & `<script setup>`:** Всегда используй Composition API и синтаксис `<script setup>` для лучшей организации логики, типизации и tree-shaking.
- **Типизация пропсов и событий:** Всегда явно определяй и типизируй пропсы и события. Используй TypeScript-интерфейсы или runtime-валидацию для документирования контракта компонента.
  ```vue
  <script setup lang="ts">
  interface Props {
    title: string;
    items?: Array<{ id: number; name: string }>;
  }
  const props = withDefaults(defineProps<Props>(), { items: () => [] });
  const emit = defineEmits<{ (e: "itemSelected", id: number): void }>();
  </script>
  ```
- **Разделение логики и шаблона:** Не помещай сложную логику в шаблон. Выноси фильтрацию, преобразования данных в **вычисляемые свойства (computed)** или **методы**.

  ```vue
  <!-- ❌ Плохо: Сложная логика в шаблоне -->
  <div v-if="users.filter((u) => u.isActive).length > 0">...</div>

  <!-- ✅ Хорошо: Логика в computed -->
  <script setup>
  const activeUsers = computed(() => users.value.filter((u) => u.isActive));
  </script>
  <template>
    <div v-if="activeUsers.length > 0">...</div>
  </template>
  ```

- **Ключ (key) для v-for:** Всегда используй уникальный и стабильный `:key` с директивой `v-for`, особенно для списков компонентов.
- **Избегай v-if/v-for на одном элементе:** Никогда не используй `v-if` и `v-for` на одном HTML-элементе. Если нужно отфильтровать список — используй вычисляемое свойство. Если нужно условно отобразить весь список — перемести `v-if` на родительский элемент-обёртку.

#### **8. Стили (CSS)**

- **Приоритет подходов:**
  1.  **Scoped Styles (`<style scoped>`):** Основной метод. Используй для стилей, специфичных для одного компонента. Это предотвращает "утечку" стилей.
  2.  **CSS-модули (`<style module>`):** Используй, когда нужен программный доступ к именам классов из JavaScript/TypeScript или для удобного совместного использования стилей между несколькими компонентами.
  3.  **Глобальные стили:** Храни в `assets/`. Используй только для глобальных стилей (сброс, типографика, цветовая палитра, CSS-переменные). Избегай стилей для конкретных компонентов.
- **Глубокий селектор (`:deep()`) :** Используй с осторожностью, чтобы стилизовать дочерние компоненты внутри scoped стилей. Не злоупотребляй им.

---

**Резюме для Copilot:** Всегда предлагай код, который следует этим принципам: **предсказуемая структура папок**, **согласованные правила именования**, **разделение ответственности** (компоненты/композаблы/хранилища) и **явная типизация**. Помоги разработчику писать код, который будет легко найти, понять и изменить через полгода.
